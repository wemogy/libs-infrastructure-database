"use strict";(self.webpackChunkwemogy=self.webpackChunkwemogy||[]).push([[459],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=c(n),f=a,d=m["".concat(l,".").concat(f)]||m[f]||p[f]||o;return n?r.createElement(d,i(i({ref:t},u),{},{components:n})):r.createElement(d,i({ref:t},u))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=f;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},425:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return i},default:function(){return p},frontMatter:function(){return o},metadata:function(){return s},toc:function(){return c}});var r=n(3117),a=(n(7294),n(3905));const o={slug:"/"},i="Overview",s={unversionedId:"overview",id:"overview",title:"Overview",description:"Welcome to the Infrastructure Database Libs documentation",source:"@site/docs-general/00-overview.md",sourceDirName:".",slug:"/",permalink:"/",draft:!1,editUrl:"https://github.com/wemogy/libs-infrastructure-database/edit/main/docs-general/00-overview.md",tags:[],version:"current",sidebarPosition:0,frontMatter:{slug:"/"},sidebar:"tutorialSidebar",next:{title:"Getting started",permalink:"/getting-started"}},l={},c=[{value:"Motivation",id:"motivation",level:2},{value:"Architecture",id:"architecture",level:2}],u={toc:c},m="wrapper";function p(e){let{components:t,...n}=e;return(0,a.kt)(m,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"overview"},"Overview"),(0,a.kt)("p",null,"Welcome to the Infrastructure Database Libs documentation"),(0,a.kt)("h2",{id:"motivation"},"Motivation"),(0,a.kt)("p",null,"The goal of the ",(0,a.kt)("inlineCode",{parentName:"p"},"wemogy.Infrastructure.Database")," library, is to define a unified way to abstract a database. The abstraction should be provider independent, which means that the actual implementation of the ",(0,a.kt)("inlineCode",{parentName:"p"},"IDatabaseClient")," can change without changing the rest of the implementation. Using this approach allows us to declare our interfaces once, generate an actual implementation at runtime and run the same source code against several database providers (e.g. InMemory, Azure Cosmos DB, MongoDB)."),(0,a.kt)("p",null,"Unit-testing database implementations should be automated, regardless of the database provider under test. The tests should be written in an abstract way and should be successful, regardless if a cosmos/mongo-db or in-memory database is being tested."),(0,a.kt)("h2",{id:"architecture"},"Architecture"),(0,a.kt)("mermaid",{value:"classDiagram\n  OfficialAzureCosmosDbClient <.. CosmosDatabaseClient: use\n  OfficialMongoDbClient <.. MongoDatabaseClient: use\n\n  class OfficialAzureCosmosDbClient{\n  }\n  class CosmosDatabaseClient{\n  }\n\n\n  class OfficialMongoDbClient{\n  }\n  class MongoDatabaseClient{\n  }\n\n  class InMemoryDatabaseClient{\n  }\n\n  CosmosDatabaseClient --|> IDatabaseClient : implements\n  MongoDatabaseClient --|> IDatabaseClient : implements\n  InMemoryDatabaseClient --|> IDatabaseClient : implements\n\n  class IDatabaseClient {\n    <<interface>>\n  }\n\n  IDatabaseClient <.. DatabaseRepository: use\n\n  class DatabaseRepository {\n  }"}))}p.isMDXComponent=!0}}]);